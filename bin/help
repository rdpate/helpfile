#!/bin/sh -ue
#.help
# help COMMAND
#
# Show help for COMMAND.
#
# Options:
#     --location    show location of help text instead
#     --max-wrap=N  wrap lines to max length of N
#     --no-wrap     don't wrap lines

fatal() {
    printf %s\\n "$(basename "$0") error: $2" >&2
    exit "$1"
}

location_only=false
wrap=true
min_width=20
max_width=75
if [ -t 1 ]; then
    stdout_terminal=true
else
    stdout_terminal=false
fi
handle_option() {
    case "$1" in
        location)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            location_only=true
            ;;
        no-wrap)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            wrap=false
            ;;
        max-wrap)
            [ $# = 2 ] || fatal 64 "missing value for option $1"
            if [ x"$2" = x0 -o x"$2" != x"$(printf %s "$2" | tr -c -d 0-9)" ]; then
                fatal 64 "invalid value for option $1"
            fi
            max_width="$(($2 + 0))"
            if ! [ 0 -lt "$max_width" ]; then
                fatal 64 "invalid value for option $1"
            fi
            ;;
        *)
            fatal 64 "unknown option: $1"
            ;;
    esac
}

while [ $# -gt 0 ]; do
    case "$1" in
        --)
            shift
            break;;
        --*=*)
            x="${1#--}"
            handle_option "${x%%=*}" "${x#*=}"
            shift;;
        --*)
            handle_option "${1#--}"
            shift;;
        -?*)
            if [ ${#1} = 2 ]; then
                handle_option "${1#-}"
            else
                v="${1#??}"
                x="${1%"$v"}"
                handle_option "${x#-}" "$v"
            fi
            shift;;
        *)
            break;;
    esac
done


if [ $# -eq 0 ]; then
    fatal 64 'expected arguments: COMMAND'
elif [ $# -gt 1 ]; then
    fatal 64 'subsections not yet supported'
fi

main() {
    command="$(which "$1")" || fatal 69 "unknown command: $1"
    if inline_help "$1" <"$command"; then
        return
    elif [ "$?" = 2 ]; then
        if file_help "$1"; then
            return
        fi
        case "$1" in
            */*)
                fatal 69 "help text not found: $1"
                ;;
        esac
        exec man 1 "$1"
    fi
}

inline_help() {
    read -r line || fatal 69 "help text not found: $1"
    case "$line" in
        '#!'*) ;;
        *)
            return 2
            ;;
    esac
    while :; do
        read -r line || fatal 69 "help text not found: $1"
        line="$(printf "$line" | sed -r 's/ *$//')"
        case "$line" in
            '#.help')
                if $location_only; then
                    printf 'inline %s\n' "$command"
                else
                    extract_help_text | output_text
                fi
                return
                ;;
            '#'*)
                ;;
            *)
                return 2
                ;;
        esac
    done
}
extract_help_text() {
    while :; do
        read -r line || break
        line="$(printf "$line" | sed -r 's/ +$//')"
        case "$line" in
            '##'*)
                ;;
            '# '*)
                printf %s\\n "${line#??}"
                ;;
            '#')
                printf \\n
                ;;
            *)
                break
                ;;
        esac
    done
}

file_help() {
    while :; do
        dirname="$(dirname "$1")"
        target="$dirname/helptext/$(basename "$1").txt"
        if [ -e "$target" ]; then
            if $location_only; then
                printf 'file %s\n' "$target"
            else
                output_text <"$target"
            fi
            break
        fi
        if [ -L "$1" ]; then
            link="$(readlink "$1")"
            case "$link" in
                /*)
                    set -- "$link"
                    ;;
                *)
                    set -- "$dirname/$link"
                    ;;
            esac
        else
            return 1
        fi
    done
}

output_text() {
    if ! $wrap; then
        if $stdout_terminal; then
            "${PAGER:-less}"
        else
            cat
        fi
        return
    fi

    if $stdout_terminal; then
        width="$(tput cols)" || width="${COLUMNS:-80}"
    else
        width="${COLUMNS:-80}"
    fi
    if [ "$max_width" -le "$width" ]; then
        width="$max_width"
    elif [ "$min_width" -ge "$width" ]; then
        width="$min_width"
    fi

    if $stdout_terminal; then
        fold -s -w"$width" | sed -r 's/ +$//' | "${PAGER:-less}"
    else
        fold -s -w"$width" | sed -r 's/ +$//'
    fi
}

main "$1"
