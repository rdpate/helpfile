#!/bin/sh -ue
#.help
# %helpfile/helpcmd NAME [SUBTOPIC..]
#
# Show NAME's help overview or SUBTOPIC help.  Output is suitable for fixed-width display.
#
# Options:
# -v  --version     version instead of help
# -s  --short       help synopsis (or version string) only
#     --lang=L      use L instead of $LC_ALL, $LC_CTYPE, or $LANG
#
# -c  --command     lookup through $PATH if NAME lacks "/", like which(1)
#     --wrap=N      wrap lines to N width or 0 for no wrap
#     --no-wrap     --wrap=0
#
#     --debug-locations     show locations on stderr while searching

base_prog="$(readlink -f "$0")"
fatal() {
    printf %s\\n "$base_prog error: $2" >&2
    exit "$1"
}

locate_flags=
short_output=false
wrap=true
min_width=20
max_width=75
user_lang=
if [ -t 1 ]; then
    stdout_terminal=true
else
    stdout_terminal=false
fi
handle_option() {
    case "$1" in
        c|command)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            locate_flags="$locate_flags --command"
            ;;
        debug-locations)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            locate_flags="$locate_flags --debug-locations"
            ;;
        lang)
            [ $# = 2 ] || fatal 64 "expected value for option $1"
            user_lang="$2"
            ;;
        s|short)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            short_output=true
            ;;
        wrap)
            [ $# = 2 ] || fatal 64 "missing value for option $1"
            if [ 0 = "$2" ]; then
                wrap=false
            else
                if [ x"$2" != x"$(printf %s "$2" | tr -c -d 0-9)" ]; then
                    fatal 64 "invalid numeric value for option $1"
                fi
                max_width="$2"
            fi
            ;;
        no-wrap)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            wrap=false
            ;;
        v|version)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            locate_flags="$locate_flags --version"
            ;;
        *)
            fatal 64 "unknown option: $1"
            ;;
    esac
}

while [ $# -gt 0 ]; do
    case "$1" in
        --)
            shift
            break;;
        --*=*)
            x="${1#--}"
            handle_option "${x%%=*}" "${x#*=}"
            shift;;
        --*)
            handle_option "${1#--}"
            shift;;
        -?*)
            if [ ${#1} = 2 ]; then
                handle_option "${1#-}"
            else
                v="${1#??}"
                x="${1%"$v"}"
                handle_option "${x#-}" "$v"
            fi
            shift;;
        *)
            break;;
    esac
done


if [ $# -eq 0 ]; then
    fatal 64 'expected arguments: NAME [SUBTOPIC..]'
fi

helpfile_locate() { # NAME [SUBTOPIC..]
    "$(dirname "$base_prog")/locate" \
        --format=txt \
        --lang="$user_lang" \
        $locate_flags \
        -- "$@"
}
main() {
    local target type format section
    target="$(helpfile_locate "$@")" || exit $?
    type="${target%% *}"
    target="${target#* }"
    if [ file = "$type" ]; then
        format="${target#*.*.}"
        case "$format" in
            txt)
                output_text <"$target"
                ;;
            *)
                fatal 69 "unknown file format: $target"
                ;;
        esac
        return 0
    fi
    section="${target%% *}"
    target="${target#* }"
    case "$type" in
        man)
            exec man "$section" "$target"
            ;;
        internal)
            show_internal_section "$section" "$target" || fatal 70 'unable to read internal section'
            return 0
            ;;
        *)
            fatal 70 "unknown help type: $type $section $target"
            ;;
    esac
}

show_internal_section() { # SECTION FILE
    local line
    sed -r 's/ +$//' "$2" | \
    while :; do
        read -r line || return 2
        case "$line" in
            "#.$1")
                internal_section_extract_text | output_text
                return 0
                ;;
            '#'*)
                ;;
            *)
                return 2
                ;;
        esac
    done
}
internal_section_extract_text() { # <lines
    # Read lines from stdin until end of section; write to stdout.
    local line
    while :; do
        read -r line || return 0
        case "$line" in
            '##'*)
                ;;
            '# '*)
                printf %s\\n "${line#??}"
                ;;
            '#')
                printf \\n
                ;;
            *)
                break
                ;;
        esac
    done
}

if $short_output; then
    output_text() {
        sed -r '/^#/d' | \
            sed -n '/^$/q; p' | \
            output_text_full
    }
else
    output_text() {
        sed -r '/^#/d' | \
            output_text_full
    }
fi
output_text_full() {
    if ! $wrap; then
        if $stdout_terminal; then
            "${PAGER:-less}"
        else
            cat
        fi
        return
    fi

    if $stdout_terminal; then
        width="$(tput cols)" || width="${COLUMNS:-80}"
    else
        width="${COLUMNS:-80}"
    fi
    if [ "$max_width" -le "$width" ]; then
        width="$max_width"
    elif [ "$min_width" -ge "$width" ]; then
        width="$min_width"
    fi

    if $stdout_terminal; then
        fold -s -w"$width" | sed -r 's/ +$//' | "${PAGER:-less}"
    else
        fold -s -w"$width" | sed -r 's/ +$//'
    fi
}

main "$@"
