#!/bin/sh -ue
#.help
# %helpfile/locate NAME [SUBTOPIC..]
#
# Locate filename for NAME's help, either overview or for SUBTOPIC.
#
# Output on success is "file FILENAME", "internal SECTION FILENAME", or "man SECTION NAME".
#
# Options:
# -v  --version     version instead of help (--section=version)
#     --lang=L      use L instead of $LC_ALL, $LC_CTYPE, or $LANG
#     --format=F    preferred formats, comma separated
# -a  --all         list all matches instead of first
#
# -c  --command     lookup through $PATH if NAME lacks "/", like which(1)
#
#     --section=S   locate section S (default: help)
#     --debug-locations     show locations on stderr while searching

fatal() {
    printf %s\\n "$(readlink -f "$0") error: $2" >&2
    exit "$1"
}

section=help
user_lang=
user_lang_country=
first_lang_file=
pref_formats=
show_all=false
path_lookup=false
debug_locations=false
handle_option() {
    local x
    case "$1" in
        a|all)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            show_all=true
            ;;
        c|command)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            path_lookup=true
            ;;
        debug-locations)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            debug_locations=true
            ;;
        format)
            [ $# = 2 ] || fatal 64 "missing value for option $1"
            x="$(printf %s "$2" | LC_ALL=C tr -d -c \\-A-Za-z0-9.,_)"
            if [ x"$x" != x"$2" ]; then
                fatal 64 'invalid --format value'
            fi
            pref_formats="$(printf %s "$2" | tr , ' ')"
            ;;
        lang)
            [ $# = 2 ] || fatal 64 "missing value for option $1"
            user_lang_country="$2"
            ;;
        section)
            [ $# = 2 ] || fatal 64 "missing value for option $1"
            [ -n "$2" ] || fatal 64 "empty value for option $1"
            section="$2"
            ;;
        v|version)
            [ $# = 1 ] || fatal 64 "unexpected value for option $1"
            section=version
            ;;
        *)
            fatal 64 "unknown option: $1"
            ;;
    esac
}

while [ $# -gt 0 ]; do
    case "$1" in
        --)
            shift
            break;;
        --*=*)
            x="${1#--}"
            handle_option "${x%%=*}" "${x#*=}"
            shift;;
        --*)
            handle_option "${1#--}"
            shift;;
        -?*)
            if [ ${#1} = 2 ]; then
                handle_option "${1#-}"
            else
                v="${1#??}"
                x="${1%"$v"}"
                handle_option "${x#-}" "$v"
            fi
            shift;;
        *)
            break;;
    esac
done


if [ $# -eq 0 ]; then
    fatal 64 'expected arguments: NAME'
else
    check_args() {
        local x
        if [ '' = "$1" ]; then
            fatal 64 'invalid empty NAME'
        fi
        shift
        for x; do
            case "$x" in
                '')
                    fatal 64 'invalid SUBTOPIC: empty argument'
                    ;;
                .*|*/.*)
                    fatal 64 'invalid SUBTOPIC: leading period'
                    ;;
                /)
                    fatal 64 'invalid SUBTOPIC: bad name'
            esac
        done
    }
    check_args "$@"
fi

check_user_lang_country() {
    user_lang_country="$(printf %s "${user_lang_country%%.*}" | tr A-Z a-z)"
    case "$user_lang_country" in
        [abcdefghijklmnopqrstuvwxyz][abcdefghijklmnopqrstuvwxyz])
            user_lang="$user_lang_country"
            user_lang_country=
            ;;
        [abcdefghijklmnopqrstuvwxyz][abcdefghijklmnopqrstuvwxyz]_[abcdefghijklmnopqrstuvwxyz][abcdefghijklmnopqrstuvwxyz])
            user_lang="${user_lang_country%_*}"
            ;;
        *)
            user_lang=
            user_lang_country=
            return 1
            ;;
    esac
}
if [ -n "$user_lang_country" ]; then
    if [ none = "$user_lang_country" ]; then
        user_lang=
        user_lang_country=
    else
        check_user_lang_country || fatal 64 'invalid --lang value'
    fi
else
    for user_lang_country in "${LC_ALL:-}" "${LC_CTYPE:-}" "${LANG:-}"; do
        if check_user_lang_country; then
            break
        fi
    done
fi

main() {
    local orig1 file
    orig1="$1"
    if $path_lookup; then
        case "$1" in
            */*) ;;
            *)
                file="$(which "$1" 2>/dev/null)" || fatal 69 "not found in PATH: $1"
                shift
                set -- "$file" "$@"
                ;;
        esac
    fi
    if $show_all; then
        find_helpfile "$section" "$@" || true
        find_internal_section "$section" "$@" || true
        if [ $path_lookup = true -a help = "$section" -a $# = 1 ]; then
            case "$orig1" in
                */*) ;;
                *' '*) ;;
                *)
                    printf 'man 1 %s\n' "$orig1"
                    ;;
            esac
        fi
    else
        if find_helpfile "$section" "$@"; then
            return 0
        elif find_internal_section "$section" "$@"; then
            return 0
        elif [ $path_lookup = true -a help = "$section" -a $# = 1 ]; then
            case "$orig1" in
                */*) ;;
                *' '*)
                    fatal 69 "defaulting to man with space in command: $orig1"
                    ;;
                *)
                    printf 'man 1 %s\n' "$orig1"
                    return 0
                    ;;
            esac
        fi
        fatal 69 "$section not found: $*"
    fi
}

find_helpfile() { # SECTION FILE [SUBTOPIC..]
    local section file subtopic left right dir link
    section="$1"
    file="$2"
    shift 2
    if [ $# = 0 ]; then
        subtopic=
    else
        subtopic="$(printf /%s "$@" | sed -r 's,//+,/,g; s,/+$,,')"
    fi
    left=
    right="$(readlink -f "$(dirname "$file")")/$(basename "$file")"
    case "$right" in
        */..*)
            fatal 69 'basename with two leading periods'
            ;;
        */.)
            right="${right%/.}"
            ;;
    esac
    orig_right="$right"
    right="$(printf %s "$right" | sed -r 's,/\.,/,g')"
    while :; do
        dir="$left/help$right$subtopic"
        if $debug_locations; then
            printf 'trying file %s.LANG.FORMAT\n' "$dir/$section" >&2
        fi
        if [ -d "$dir" ]; then
            if find_helpfile_lang_format "$dir/$section"; then
                if ! $show_all; then
                    return 0
                fi
            fi
        fi

        case "$right" in
            /*/*)
                orig_right="${orig_right#/}"
                right="${right#/}"
                left="$left/${orig_right%%/*}"
                orig_right="/${orig_right#*/}"
                right="/${right#*/}"
                continue
                ;;
            '')
                ;;
            *)
                left="$left$orig_right"
                orig_right=
                right=
                continue
                ;;
        esac
        if [ -L "$file" ]; then
            link="$(readlink "$file")"
            case "$link" in
                /*)
                    file="$link"
                    ;;
                *)
                    file="$(dirname "$file")/$link"
                    ;;
            esac
            left=
            right="$(readlink -f "$(dirname "$file")")/$(basename "$file")"
            case "$right" in
                */..*)
                    fatal 69 'basename with two leading periods'
                    ;;
                */.)
                    right="${right%/.}"
                    ;;
            esac
            orig_right="$right"
            right="$(printf %s "$right" | sed -r 's,/\.,/,g')"
        else
            if [ -n "$first_lang_file" ]; then
                printf 'file %s\n' "$first_lang_file"
                return 0
            fi
            return 1
        fi
    done
}

find_helpfile_lang_format() { # BASE
    local lang target format
    if [ -n "$user_lang" ]; then
        if $show_all; then
            for lang in $user_lang_country $user_lang any; do
                for target in "$1.$lang."?*; do
                    if [ -e "$target" ]; then
                        printf 'file %s\n' "$target"
                    fi
                done
            done
        else
            for format in $pref_formats; do
                for lang in $user_lang_country $user_lang any; do
                    target="$1.$lang.$format"
                    if [ -e "$target" ]; then
                        printf 'file %s\n' "$target"
                        return 0
                    fi
                done
            done
            for lang in $user_lang_country $user_lang any; do
                for target in "$1.$lang."?*; do
                    if [ -e "$target" ]; then
                        printf 'file %s\n' "$target"
                        return 0
                    fi
                done
            done
            if [ -z "$first_lang_file" ]; then
                for target in "$1."[abcdefghijklmnopqrstuvwxyz][abcdefghijklmnopqrstuvwxyz].?* "$1."[abcdefghijklmnopqrstuvwxyz][abcdefghijklmnopqrstuvwxyz]_[abcdefghijklmnopqrstuvwxyz][abcdefghijklmnopqrstuvwxyz].?*; do
                    if [ -e "$target" ]; then
                        first_lang_file="$target"
                        return 1
                    fi
                done
            fi
            return 1
        fi
    else
        for target in "$1.any".?* "$1."[abcdefghijklmnopqrstuvwxyz][abcdefghijklmnopqrstuvwxyz].?* "$1."[abcdefghijklmnopqrstuvwxyz][abcdefghijklmnopqrstuvwxyz]_[abcdefghijklmnopqrstuvwxyz][abcdefghijklmnopqrstuvwxyz].?*; do
            if [ -e "$target" ]; then
                printf 'file %s\n' "$target"
                if ! $show_all; then
                    return 0
                fi
            fi
        done
        return 1
    fi
}

find_internal_section() { # SECTION FILE [SUBTOPIC..]
    # Return 2 if internal section not found.
    if [ $# != 2 -o ! -f "$2" ]; then
        return 2
    fi
    if $debug_locations; then
        printf 'trying internal sections in %s\n' "$2" >&2
    fi
    if sed -r 's/ +$//' "$2" | find_internal_section_read "$1"; then
        printf 'internal %s %s\n' "$1" "$2"
        return 0
    else
        return 2
    fi
}
find_internal_section_read() { # SECTION <lines
    local line
    while :; do
        read -r line || return 2
        case "$line" in
            "#.$1"|"#.$1 "*)
                return 0
                ;;
            '#'*)
                ;;
            *)
                return 2
                ;;
        esac
    done
}

main "$@"
